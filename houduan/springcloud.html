<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>目录 | 慢下来~享受当下~</title>
    <meta name="generator" content="VuePress 1.9.8">
    <link rel="icon" href="/assets/img/favicon.ico">
    <meta name="description" content="">
    <meta name="keywords" content="网站关键词">
    <meta name="author" content="zch1337">
    
    <link rel="preload" href="/assets/css/0.styles.7b36eabc.css" as="style"><link rel="preload" href="/assets/js/app.dd397728.js" as="script"><link rel="preload" href="/assets/js/2.6430ac10.js" as="script"><link rel="preload" href="/assets/js/22.d6b62e7e.js" as="script"><link rel="prefetch" href="/assets/js/10.de11ce4e.js"><link rel="prefetch" href="/assets/js/11.eb24f3d9.js"><link rel="prefetch" href="/assets/js/12.58efe507.js"><link rel="prefetch" href="/assets/js/13.3d3cb395.js"><link rel="prefetch" href="/assets/js/14.163292db.js"><link rel="prefetch" href="/assets/js/15.0eeb79e2.js"><link rel="prefetch" href="/assets/js/16.0fd3ccda.js"><link rel="prefetch" href="/assets/js/17.a13c3e02.js"><link rel="prefetch" href="/assets/js/18.e19d705d.js"><link rel="prefetch" href="/assets/js/19.52c11801.js"><link rel="prefetch" href="/assets/js/20.4cfdf5ad.js"><link rel="prefetch" href="/assets/js/21.b6ab34b9.js"><link rel="prefetch" href="/assets/js/23.5bfd3dd2.js"><link rel="prefetch" href="/assets/js/24.8f60b85b.js"><link rel="prefetch" href="/assets/js/25.23e92ce8.js"><link rel="prefetch" href="/assets/js/26.079d4c49.js"><link rel="prefetch" href="/assets/js/27.2a42a3bc.js"><link rel="prefetch" href="/assets/js/28.96e30dd4.js"><link rel="prefetch" href="/assets/js/29.92dc21e8.js"><link rel="prefetch" href="/assets/js/3.7ceae309.js"><link rel="prefetch" href="/assets/js/30.a44ddd87.js"><link rel="prefetch" href="/assets/js/31.ebffffad.js"><link rel="prefetch" href="/assets/js/32.cbeff704.js"><link rel="prefetch" href="/assets/js/33.f34223b0.js"><link rel="prefetch" href="/assets/js/4.3357b40a.js"><link rel="prefetch" href="/assets/js/5.1d0c2d3a.js"><link rel="prefetch" href="/assets/js/6.aeb7dc84.js"><link rel="prefetch" href="/assets/js/7.f2b24add.js"><link rel="prefetch" href="/assets/js/8.b624c3e8.js"><link rel="prefetch" href="/assets/js/9.4891ca45.js">
    <link rel="stylesheet" href="/assets/css/0.styles.7b36eabc.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/assets/img/hero.png" alt="慢下来~享受当下~" class="logo"> <span class="site-name can-hide">慢下来~享受当下~</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="英语" class="dropdown-title"><span class="title">英语</span> <span class="arrow down"></span></button> <button type="button" aria-label="英语" class="mobile-dropdown-title"><span class="title">英语</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/yingyu/fangfa.html" class="nav-link">
  方法
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><span class="title">前端</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端" class="mobile-dropdown-title"><span class="title">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/yunwei/sanjianke.html" class="nav-link">
  三剑客
</a></li><li class="dropdown-item"><!----> <a href="/yunwei/vue.html" class="nav-link">
  vue全家桶
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="后端" class="dropdown-title"><span class="title">后端</span> <span class="arrow down"></span></button> <button type="button" aria-label="后端" class="mobile-dropdown-title"><span class="title">后端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          第一阶段-基础
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/houduan/javase.html" class="nav-link">
  javase
</a></li><li class="dropdown-subitem"><a href="/houduan/mysql.html" class="nav-link">
  mysql
</a></li><li class="dropdown-subitem"><a href="/houduan/jdbc.html" class="nav-link">
  jdbc
</a></li><li class="dropdown-subitem"><a href="/houduan/servlet.html" class="nav-link">
  servlet
</a></li></ul></li><li class="dropdown-item"><h4>
          第二阶段-框架
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/houduan/maven.html" class="nav-link">
  maven
</a></li><li class="dropdown-subitem"><a href="/houduan/spring.html" class="nav-link">
  spring
</a></li><li class="dropdown-subitem"><a href="/houduan/springMVC.html" class="nav-link">
  springMVC
</a></li><li class="dropdown-subitem"><a href="/houduan/mybatis+PLUS.html" class="nav-link">
  mybatis+PLUS
</a></li><li class="dropdown-subitem"><a href="/houduan/springboot.html" class="nav-link">
  springboot
</a></li><li class="dropdown-subitem"><a href="/houduan/redis.html" class="nav-link">
  redis
</a></li><li class="dropdown-subitem"><a href="/houduan/springsecurity.html" class="nav-link">
  springsecurity
</a></li></ul></li><li class="dropdown-item"><h4>
          第三阶段-微服务
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/houduan/springcloud.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  springcloud
</a></li><li class="dropdown-subitem"><a href="/houduan/springcloudAlibaba.html" class="nav-link">
  springcloudAlibaba
</a></li><li class="dropdown-subitem"><a href="/houduan/rabbitMQ.html" class="nav-link">
  rabbitMQ
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="运维" class="dropdown-title"><span class="title">运维</span> <span class="arrow down"></span></button> <button type="button" aria-label="运维" class="mobile-dropdown-title"><span class="title">运维</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/yunwei/linux.html" class="nav-link">
  linux
</a></li><li class="dropdown-item"><!----> <a href="/yunwei/nginx.html" class="nav-link">
  nginx
</a></li><li class="dropdown-item"><!----> <a href="/yunwei/docker.html" class="nav-link">
  docker
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="高效工具" class="dropdown-title"><span class="title">高效工具</span> <span class="arrow down"></span></button> <button type="button" aria-label="高效工具" class="mobile-dropdown-title"><span class="title">高效工具</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/gaoxiao/vim.html" class="nav-link">
  vim
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="项目总结" class="dropdown-title"><span class="title">项目总结</span> <span class="arrow down"></span></button> <button type="button" aria-label="项目总结" class="mobile-dropdown-title"><span class="title">项目总结</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/prosummary/vueS.html" class="nav-link">
  vue项目
</a></li><li class="dropdown-item"><!----> <a href="/prosummary/javaS.html" class="nav-link">
  java项目
</a></li><li class="dropdown-item"><!----> <a href="/prosummary/前后端项目开发流程.html" class="nav-link">
  前后端项目搭建
</a></li><li class="dropdown-item"><!----> <a href="/prosummary/后端知识总结.html" class="nav-link">
  后端开发流程
</a></li></ul></div></div><div class="nav-item"><a href="http://www.zch1337.xyz/#/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  关于我
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="英语" class="dropdown-title"><span class="title">英语</span> <span class="arrow down"></span></button> <button type="button" aria-label="英语" class="mobile-dropdown-title"><span class="title">英语</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/yingyu/fangfa.html" class="nav-link">
  方法
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><span class="title">前端</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端" class="mobile-dropdown-title"><span class="title">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/yunwei/sanjianke.html" class="nav-link">
  三剑客
</a></li><li class="dropdown-item"><!----> <a href="/yunwei/vue.html" class="nav-link">
  vue全家桶
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="后端" class="dropdown-title"><span class="title">后端</span> <span class="arrow down"></span></button> <button type="button" aria-label="后端" class="mobile-dropdown-title"><span class="title">后端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          第一阶段-基础
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/houduan/javase.html" class="nav-link">
  javase
</a></li><li class="dropdown-subitem"><a href="/houduan/mysql.html" class="nav-link">
  mysql
</a></li><li class="dropdown-subitem"><a href="/houduan/jdbc.html" class="nav-link">
  jdbc
</a></li><li class="dropdown-subitem"><a href="/houduan/servlet.html" class="nav-link">
  servlet
</a></li></ul></li><li class="dropdown-item"><h4>
          第二阶段-框架
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/houduan/maven.html" class="nav-link">
  maven
</a></li><li class="dropdown-subitem"><a href="/houduan/spring.html" class="nav-link">
  spring
</a></li><li class="dropdown-subitem"><a href="/houduan/springMVC.html" class="nav-link">
  springMVC
</a></li><li class="dropdown-subitem"><a href="/houduan/mybatis+PLUS.html" class="nav-link">
  mybatis+PLUS
</a></li><li class="dropdown-subitem"><a href="/houduan/springboot.html" class="nav-link">
  springboot
</a></li><li class="dropdown-subitem"><a href="/houduan/redis.html" class="nav-link">
  redis
</a></li><li class="dropdown-subitem"><a href="/houduan/springsecurity.html" class="nav-link">
  springsecurity
</a></li></ul></li><li class="dropdown-item"><h4>
          第三阶段-微服务
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/houduan/springcloud.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  springcloud
</a></li><li class="dropdown-subitem"><a href="/houduan/springcloudAlibaba.html" class="nav-link">
  springcloudAlibaba
</a></li><li class="dropdown-subitem"><a href="/houduan/rabbitMQ.html" class="nav-link">
  rabbitMQ
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="运维" class="dropdown-title"><span class="title">运维</span> <span class="arrow down"></span></button> <button type="button" aria-label="运维" class="mobile-dropdown-title"><span class="title">运维</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/yunwei/linux.html" class="nav-link">
  linux
</a></li><li class="dropdown-item"><!----> <a href="/yunwei/nginx.html" class="nav-link">
  nginx
</a></li><li class="dropdown-item"><!----> <a href="/yunwei/docker.html" class="nav-link">
  docker
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="高效工具" class="dropdown-title"><span class="title">高效工具</span> <span class="arrow down"></span></button> <button type="button" aria-label="高效工具" class="mobile-dropdown-title"><span class="title">高效工具</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/gaoxiao/vim.html" class="nav-link">
  vim
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="项目总结" class="dropdown-title"><span class="title">项目总结</span> <span class="arrow down"></span></button> <button type="button" aria-label="项目总结" class="mobile-dropdown-title"><span class="title">项目总结</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/prosummary/vueS.html" class="nav-link">
  vue项目
</a></li><li class="dropdown-item"><!----> <a href="/prosummary/javaS.html" class="nav-link">
  java项目
</a></li><li class="dropdown-item"><!----> <a href="/prosummary/前后端项目开发流程.html" class="nav-link">
  前后端项目搭建
</a></li><li class="dropdown-item"><!----> <a href="/prosummary/后端知识总结.html" class="nav-link">
  后端开发流程
</a></li></ul></div></div><div class="nav-item"><a href="http://www.zch1337.xyz/#/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  关于我
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>目录</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/houduan/springcloud.html#前置知识" class="sidebar-link">前置知识</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/houduan/springcloud.html#eureke和zookeeper区别" class="sidebar-link">eureke和zookeeper区别</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/houduan/springcloud.html#cap原则" class="sidebar-link">CAP原则</a></li><li class="sidebar-sub-header"><a href="/houduan/springcloud.html#区别" class="sidebar-link">区别</a></li></ul></li><li><a href="/houduan/springcloud.html#搭建eureke" class="sidebar-link">搭建eureke</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/houduan/springcloud.html#_1-搭建server" class="sidebar-link">1.搭建server</a></li><li class="sidebar-sub-header"><a href="/houduan/springcloud.html#_2-搭建client" class="sidebar-link">2.搭建client</a></li><li class="sidebar-sub-header"><a href="/houduan/springcloud.html#_3-搭建集群" class="sidebar-link">3.搭建集群</a></li></ul></li><li><a href="/houduan/springcloud.html#配置文件" class="sidebar-link">配置文件</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/houduan/springcloud.html#eureka-server配置文件" class="sidebar-link">eureka-server配置文件</a></li><li class="sidebar-sub-header"><a href="/houduan/springcloud.html#eureka-client配置文件" class="sidebar-link">eureka-client配置文件</a></li></ul></li><li><a href="/houduan/springcloud.html#构建高可用-ap-的eureka集群" class="sidebar-link">构建高可用(AP)的eureka集群</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/houduan/springcloud.html#_1-eureka-server" class="sidebar-link">1.eureka-server</a></li><li class="sidebar-sub-header"><a href="/houduan/springcloud.html#_2-eureka-client" class="sidebar-link">2.eureka-client</a></li><li class="sidebar-sub-header"><a href="/houduan/springcloud.html#_3-搭建eureka-server集群的终极方案" class="sidebar-link">3.搭建eureka-server集群的终极方案</a></li><li class="sidebar-sub-header"><a href="/houduan/springcloud.html#_4-搭建eureka-client集群的终极方案" class="sidebar-link">4.搭建eureka-client集群的终极方案</a></li></ul></li><li><a href="/houduan/springcloud.html#集群的深入理解" class="sidebar-link">集群的深入理解</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/houduan/springcloud.html#eureka概念理解" class="sidebar-link">Eureka概念理解</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/houduan/springcloud.html#_1-服务的注册" class="sidebar-link">1.服务的注册</a></li><li class="sidebar-sub-header"><a href="/houduan/springcloud.html#_2-服务的续约" class="sidebar-link">2.服务的续约</a></li><li class="sidebar-sub-header"><a href="/houduan/springcloud.html#_3-服务的下线" class="sidebar-link">3.服务的下线</a></li><li class="sidebar-sub-header"><a href="/houduan/springcloud.html#_4-服务的剔除" class="sidebar-link">4.服务的剔除</a></li><li class="sidebar-sub-header"><a href="/houduan/springcloud.html#_5-eureka-server端的功能" class="sidebar-link">5.eureka-server端的功能</a></li></ul></li><li><a href="/houduan/springcloud.html#eureka源码理解" class="sidebar-link">Eureka源码理解</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/houduan/springcloud.html#_1-学习源码可以排查bug和优化代码。" class="sidebar-link">1.学习源码可以排查bug和优化代码。</a></li><li class="sidebar-sub-header"><a href="/houduan/springcloud.html#_2-eureka运作原理" class="sidebar-link">2.eureka运作原理</a></li><li class="sidebar-sub-header"><a href="/houduan/springcloud.html#_3-服务注册的源码分析〖重点〗" class="sidebar-link">3.服务注册的源码分析〖重点〗</a></li><li class="sidebar-sub-header"><a href="/houduan/springcloud.html#_4-服务续约" class="sidebar-link">4.服务续约</a></li><li class="sidebar-sub-header"><a href="/houduan/springcloud.html#_5-服务发现" class="sidebar-link">5.服务发现</a></li></ul></li><li><a href="/houduan/springcloud.html#eureka服务发现和调用服务" class="sidebar-link">Eureka服务发现和调用服务</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/houduan/springcloud.html#环境" class="sidebar-link">环境</a></li><li class="sidebar-sub-header"><a href="/houduan/springcloud.html#目标" class="sidebar-link">目标</a></li><li class="sidebar-sub-header"><a href="/houduan/springcloud.html#必备知识" class="sidebar-link">必备知识</a></li><li class="sidebar-sub-header"><a href="/houduan/springcloud.html#实现" class="sidebar-link">实现</a></li><li class="sidebar-sub-header"><a href="/houduan/springcloud.html#结果" class="sidebar-link">结果</a></li></ul></li><li><a href="/houduan/springcloud.html#ibbon初理解" class="sidebar-link">ibbon初理解</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/houduan/springcloud.html#ribbon快速入门" class="sidebar-link">ribbon快速入门</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/houduan/springcloud.html#环境-2" class="sidebar-link">环境</a></li><li class="sidebar-sub-header"><a href="/houduan/springcloud.html#前置知识-2" class="sidebar-link">前置知识</a></li><li class="sidebar-sub-header"><a href="/houduan/springcloud.html#搭建consumer" class="sidebar-link">搭建consumer</a></li><li class="sidebar-sub-header"><a href="/houduan/springcloud.html#不同点" class="sidebar-link">不同点</a></li></ul></li><li><a href="/houduan/springcloud.html#ribbon负载均衡理解" class="sidebar-link">ribbon负载均衡理解</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/houduan/springcloud.html#注意点1" class="sidebar-link">注意点1</a></li><li class="sidebar-sub-header"><a href="/houduan/springcloud.html#轮训算法的代码实现" class="sidebar-link">轮训算法的代码实现</a></li></ul></li><li><a href="/houduan/springcloud.html#ribbon源码理解" class="sidebar-link">ribbon源码理解</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/houduan/springcloud.html#修改负载均衡算法" class="sidebar-link">修改负载均衡算法</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/houduan/springcloud.html#ribbon总结" class="sidebar-link">Ribbon总结</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/houduan/springcloud.html#openfeign是什么" class="sidebar-link">OpenFeign是什么？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/houduan/springcloud.html#openfeign快速入门" class="sidebar-link">OpenFeign快速入门</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/houduan/springcloud.html#环境-3" class="sidebar-link">环境</a></li><li class="sidebar-sub-header"><a href="/houduan/springcloud.html#结构" class="sidebar-link">结构</a></li><li class="sidebar-sub-header"><a href="/houduan/springcloud.html#业务" class="sidebar-link">业务</a></li><li class="sidebar-sub-header"><a href="/houduan/springcloud.html#实现-2" class="sidebar-link">实现</a></li></ul></li><li><a href="/houduan/springcloud.html#openfeign超时调用" class="sidebar-link">OpenFeign超时调用</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/houduan/springcloud.html#openfeign日志" class="sidebar-link">OpenFeign日志</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/houduan/springcloud.html#服务雪崩概念" class="sidebar-link">服务雪崩概念</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/houduan/springcloud.html#hystrix快速入门" class="sidebar-link">Hystrix快速入门</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/houduan/springcloud.html#熔断器理解" class="sidebar-link">熔断器理解</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/houduan/springcloud.html#hystrix配置" class="sidebar-link">Hystrix配置</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/houduan/springcloud.html#zipkin可视化的监控控制台" class="sidebar-link">zipkin可视化的监控控制台</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/houduan/springcloud.html#sleuth快速入门" class="sidebar-link">Sleuth快速入门</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/houduan/springcloud.html#网关的理解" class="sidebar-link">网关的理解</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/houduan/springcloud.html#网关的作用" class="sidebar-link">网关的作用</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/houduan/springcloud.html#gateway流程" class="sidebar-link">Gateway流程</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/houduan/springcloud.html#gateway和nginx的区别" class="sidebar-link">Gateway和nginx的区别</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/houduan/springcloud.html#gateway快速入门" class="sidebar-link">Gateway快速入门</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/houduan/springcloud.html#网关集群" class="sidebar-link">网关集群</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/houduan/springcloud.html#代码方式路由和断言工厂" class="sidebar-link">代码方式路由和断言工厂</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/houduan/springcloud.html#动态路由和断言工厂" class="sidebar-link">动态路由和断言工厂</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/houduan/springcloud.html#动态路由" class="sidebar-link">动态路由</a></li><li class="sidebar-sub-header"><a href="/houduan/springcloud.html#断言工厂" class="sidebar-link">断言工厂</a></li></ul></li><li><a href="/houduan/springcloud.html#过滤器" class="sidebar-link">过滤器</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/houduan/springcloud.html#自定义过滤器-token校验" class="sidebar-link">自定义过滤器-token校验</a></li></ul></li><li><a href="/houduan/springcloud.html#跨域配置" class="sidebar-link">跨域配置</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="目录"><a href="#目录" class="header-anchor">#</a> 目录</h1> <ul><li><a href="#1eureka">1.Eureka</a> <ul><li><a href="#----">前置知识</a></li> <li><a href="#eureke-zookeeper--">eureke和zookeeper区别</a> <ul><li><a href="#cap--">CAP原则</a></li> <li><a href="#--">区别</a></li></ul></li> <li><a href="#--eureke">搭建eureke</a> <ul><li><a href="#1--server">1.搭建server</a></li> <li><a href="#2--client">2.搭建client</a></li> <li><a href="#3----">3.搭建集群</a></li></ul></li> <li><a href="#----">配置文件</a> <ul><li><a href="#eureka-server----">eureka-server配置文件</a></li> <li><a href="#eureka-client----">eureka-client配置文件</a></li></ul></li> <li><a href="#------ap--eureka--">构建高可用(AP)的eureka集群</a> <ul><li><a href="#1eureka-server">1.eureka-server</a></li> <li><a href="#2eureka-client">2.eureka-client</a></li> <li><a href="#3--eureka-server-------">3.搭建eureka-server集群的终极方案</a></li> <li><a href="#4--eureka-client-------">4.搭建eureka-client集群的终极方案</a></li></ul></li> <li><a href="#-------">集群的深入理解</a></li> <li><a href="#eureka----">Eureka概念理解</a> <ul><li><a href="#1-----">1.服务的注册</a></li> <li><a href="#2-----">2.服务的续约</a></li> <li><a href="#3-----">3.服务的下线</a></li> <li><a href="#4-----">4.服务的剔除</a></li> <li><a href="#5eureka-server----">5.eureka-server端的功能</a></li></ul></li> <li><a href="#eureka----">Eureka源码理解</a> <ul><li><a href="#1--------bug------">1.学习源码可以排查bug和优化代码。</a></li> <li><a href="#2eureka----">2.eureka运作原理</a></li> <li><a href="#3-------------">3.服务注册的源码分析〖重点〗</a></li> <li><a href="#4----">4.服务续约</a></li> <li><a href="#5----">5.服务发现</a></li></ul></li> <li><a href="#eureka---------">Eureka服务发现和调用服务</a> <ul><li><a href="#--">环境</a></li> <li><a href="#--">目标</a></li> <li><a href="#----">必备知识</a></li> <li><a href="#--">实现</a></li> <li><a href="#--">结果</a></li></ul></li></ul></li> <li><a href="#2ribbon">2.Ribbon</a> <ul><li><a href="#ibbon---">ibbon初理解</a></li> <li><a href="#ribbon----">ribbon快速入门</a> <ul><li><a href="#---1">环境</a></li> <li><a href="#-----1">前置知识</a></li> <li><a href="#--consumer">搭建consumer</a></li> <li><a href="#---">不同点</a></li></ul></li> <li><a href="#ribbon------">ribbon负载均衡理解</a> <ul><li><a href="#---1">注意点1</a></li> <li><a href="#---------">轮训算法的代码实现</a></li></ul></li> <li><a href="#ribbon----">ribbon源码理解</a></li> <li><a href="#--------">修改负载均衡算法</a></li> <li><a href="#ribbon--">Ribbon总结</a></li></ul></li> <li><a href="#3openfeign">3.OpenFeign</a> <ul><li><a href="#openfeign----">OpenFeign是什么？</a></li> <li><a href="#openfeign----">OpenFeign快速入门</a> <ul><li><a href="#---2">环境</a></li> <li><a href="#--">结构</a></li> <li><a href="#--">业务</a></li> <li><a href="#---1">实现</a></li></ul></li> <li><a href="#openfeign----">OpenFeign超时调用</a></li> <li><a href="#openfeign--">OpenFeign日志</a></li></ul></li> <li><a href="#4hystrix">4.Hystrix</a> <ul><li><a href="#------">服务雪崩概念</a></li> <li><a href="#hystrix----">Hystrix快速入门</a></li> <li><a href="#-----">熔断器理解</a></li> <li><a href="#hystrix--">Hystrix配置</a></li></ul></li> <li><a href="#5---feign------">5.分布式feign的工程化结构</a></li> <li><a href="#6sleuth">6.Sleuth</a></li> <li><a href="#7----">7.监控中心</a></li> <li><a href="#8gateway">8.Gateway</a> <ul><li><a href="#-----">网关的理解</a></li> <li><a href="#-----">网关的作用</a></li> <li><a href="#gateway--">Gateway流程</a></li> <li><a href="#gateway-nginx---">Gateway和nginx的区别</a></li> <li><a href="#gateway----">Gateway快速入门</a></li> <li><a href="#----">网关集群</a></li> <li><a href="#-----------">代码方式路由和断言工厂</a></li> <li><a href="#----">动态路由</a></li> <li><a href="#---">过滤器</a> <ul><li><a href="#-------token--">自定义过滤器-token校验</a></li></ul></li></ul></li></ul> <p><small><i><a href="http://ecotrust-canada.github.io/markdown-toc/">Table of contents generated with markdown-toc</a></i></small></p> <h1 id="_1-eureka"><a href="#_1-eureka" class="header-anchor">#</a> 1.Eureka</h1> <h2 id="前置知识"><a href="#前置知识" class="header-anchor">#</a> 前置知识</h2> <p>eureke是什么？</p> <p>注册发现中心</p> <p>注册中心在微服务的架构中相当于一个“服务的通讯录”。当一个服务启动时，需要向注册中心注册服务同时缓存服务列表到本地。当服务A想调用服务B时根据服务列表拿到服务B的地址然后调用。</p> <h2 id="eureke和zookeeper区别"><a href="#eureke和zookeeper区别" class="header-anchor">#</a> eureke和zookeeper区别</h2> <h3 id="cap原则"><a href="#cap原则" class="header-anchor">#</a> CAP原则</h3> <p>在分布式中，一致性C、可用性A和分区容错性P三者不可兼得，最多同时实现其中两个。</p> <p>C一致性：集群中的数据是一致的。</p> <p>A可用性：当某个机子挂掉，整个集群可以继续对外服务。</p> <p>P分区容错性：由于网络或分区等原因导致各个机器的数据短暂不一样。</p> <p>CP：当某个机子挂掉时，集群不能对外提供服务，需要一定时间来恢复。</p> <p>AP：高可用。当某个机子挂掉时，集群能对外服务，但数据可能是不一致的。</p> <h3 id="区别"><a href="#区别" class="header-anchor">#</a> 区别</h3> <p>zk遵循CP原则：数据一致；eureke遵循AP：高可用。</p> <h2 id="搭建eureke"><a href="#搭建eureke" class="header-anchor">#</a> 搭建eureke</h2> <p>搭建注册中心，并能够提供注册服务。</p> <h3 id="_1-搭建server"><a href="#_1-搭建server" class="header-anchor">#</a> 1.搭建server</h3> <p>1.添加依赖</p> <div class="language- extra-class"><pre class="language-text"><code>eureka-server
</code></pre></div><p>2.pom文件</p> <div class="language- extra-class"><pre class="language-text"><code>1.修改spring-boot版本号，需要一致
&lt;version&gt;2.3.12.RELEASE&lt;/version&gt;
2.修改springcloud版本
&lt;spring-cloud.version&gt;Hoxton.SR12&lt;/spring-cloud.version&gt;
</code></pre></div><p>3.application.yml</p> <div class="language- extra-class"><pre class="language-text"><code>server:
  port: 8761 #eureka默认端口
spring:
  application:
    name: eureka-server #应用名称
</code></pre></div><p>4.修改启动程序</p> <div class="language- extra-class"><pre class="language-text"><code>@SpringBootApplication
@EnableEurekaServer // 开启注册中心的功能
public class EurekaServerApplication {

    public static void main(String[] args) {
        SpringApplication.run(EurekaServerApplication.class, args);
    }

}
</code></pre></div><p>5.Edit Configurations</p> <div class="language- extra-class"><pre class="language-text"><code>Name：EurekaServerApplication
</code></pre></div><p>6.进入server管理界面查看</p> <div class="language- extra-class"><pre class="language-text"><code>http://localhost:8761/
</code></pre></div><h3 id="_2-搭建client"><a href="#_2-搭建client" class="header-anchor">#</a> 2.搭建client</h3> <p>1.添加依赖</p> <div class="language- extra-class"><pre class="language-text"><code>1.eureka-client
2.spring
</code></pre></div><p>2.pom文件</p> <div class="language- extra-class"><pre class="language-text"><code>1.修改spring-boot版本号，需要一致
&lt;version&gt;2.3.12.RELEASE&lt;/version&gt;
2.修改springcloud版本
&lt;spring-cloud.version&gt;Hoxton.SR12&lt;/spring-cloud.version&gt;
</code></pre></div><p>3.application.yml</p> <div class="language- extra-class"><pre class="language-text"><code>server:
  port: 8081 #没有要求随便写
spring:
  application:
    name: eureka-client-b #随便写
eureka: #注册
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka
</code></pre></div><p>4.修改启动程序</p> <div class="language- extra-class"><pre class="language-text"><code>@SpringBootApplication
@EnableEurekaClient  // 开启Client
public class EurekaClientBApplication {

    public static void main(String[] args) {
        SpringApplication.run(EurekaClientBApplication.class, args);
    }

}
</code></pre></div><p>5.Edit Configurations</p> <div class="language- extra-class"><pre class="language-text"><code>Name：EurekaClientBApplication
</code></pre></div><p>6.进入server管理界面查看</p> <div class="language- extra-class"><pre class="language-text"><code>http://localhost:8761/
</code></pre></div><h3 id="_3-搭建集群"><a href="#_3-搭建集群" class="header-anchor">#</a> 3.搭建集群</h3> <p>同一个实例，不同端口。复制一个项目，就修改端口号。</p> <p>目标：让EurekaClientA搞2台。</p> <p>1.根据配置文件增加</p> <div class="language- extra-class"><pre class="language-text"><code>Edit Configurations -&gt; copy Configurations
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>Name: EurekaClientAApplication-2
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>Modify options -&gt; Program arguments
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>Program arguments:   --server.port=8083
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>启动 EurekaClientAApplication-2
</code></pre></div><h2 id="配置文件"><a href="#配置文件" class="header-anchor">#</a> 配置文件</h2> <p>eureka分3类 server client 实例(instance)</p> <h3 id="eureka-server配置文件"><a href="#eureka-server配置文件" class="header-anchor">#</a> eureka-server配置文件</h3> <div class="language- extra-class"><pre class="language-text"><code>server:
  port: 8761 #eureka默认端口
spring:
  application:
    name: eureka-server #应用名称

eureka:
  server:
    eviction-interval-timer-in-ms: 10000 # 服务端间隔多少毫秒做定期删除操作
    renewal-percent-threshold: 0.85 # 续约百分比 超过85%的应用没有和注册中心续约（心跳机制) 那么eureka会保护服务 不会剔除任何一个
  instance: # 实例的配置
    instance-id: ${eureka.instance.hostname}:${spring.application.name}:${server.port} #主机名称：应用名称：端口号
    hostname: localhost # 主机名称或者服务ip
    prefer-ip-address: true #以ip的形式显示具体的服务信息
    lease-expiration-duration-in-seconds: 5 # 服务实例的续约的时间间隔  eureka-server是服务端也是客户端
</code></pre></div><h3 id="eureka-client配置文件"><a href="#eureka-client配置文件" class="header-anchor">#</a> eureka-client配置文件</h3> <div class="language- extra-class"><pre class="language-text"><code>server:
  port: 8080
spring:
  application:
    name: eureka-client-a
eureka:
  client:
    service-url: # 指定注册的地址
      defaultZone: http://localhost:8761/eureka
    register-with-eureka: true # false可以不向eureka-server注册
    fetch-registry: true # 是否拉取服务列表 如果为false，该应用会找不到其他的应用
    registry-fetch-interval-seconds: 10  # 定期拉取服务列表的间隔 为了缓解服务列表的脏读问题 时间越短-&gt;脏读越少-&gt;性能消耗越大
  instance: # 实例配置
    instance-id: ${eureka.instance.hostname}:${spring.application.name}:${server.port} #主机名称：应用名称：端口号
    hostname: localhost # 应用的主机名称 最好写ip
    prefer-ip-address: true #以ip的形式显示具体的服务信息
    lease-expiration-duration-in-seconds: 10 # 服务实例的续约的时间间隔
</code></pre></div><h2 id="构建高可用-ap-的eureka集群"><a href="#构建高可用-ap-的eureka集群" class="header-anchor">#</a> 构建高可用(AP)的eureka集群</h2> <h3 id="_1-eureka-server"><a href="#_1-eureka-server" class="header-anchor">#</a> 1.eureka-server</h3> <p>eureka集群采用去中心化模式</p> <p>1.建立三个eureka-server</p> <p>2.修改pom.xml文件</p> <p>3.修改application.yml --互相注册</p> <div class="language- extra-class"><pre class="language-text"><code>server-a

server:
  port: 8761 #eureka默认端口
spring:
  application:
    name: eureka-server #应用名称
eureka:
  client:
    service-url: #向其他机器注册 默认向8761注册
      defaultZone: http://localhost:8762/eureka,http://localhost:8763/eureka
  instance: # 实例的配置
    instance-id: ${eureka.instance.hostname}:${spring.application.name}:${server.port} #主机名称：应用名称：端口号
    hostname: localhost # 主机名称或者服务ip
    prefer-ip-address: true #以ip的形式显示具体的服务信息
    lease-expiration-duration-in-seconds: 5 # 服务实例的续约的时间间隔  eureka-server是服务端也是客户端
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>server-b

server:
  port: 8762 #eureka默认端口
spring:
  application:
    name: eureka-server #应用名称不能改 这里是集群
eureka:
  client:
    service-url: #向其他机器注册 默认向8761注册
      defaultZone: http://localhost:8761/eureka,http://localhost:8763/eureka
  instance: # 实例的配置
    instance-id: ${eureka.instance.hostname}:${spring.application.name}:${server.port} #主机名称：应用名称：端口号
    hostname: localhost # 主机名称或者服务ip
    prefer-ip-address: true #以ip的形式显示具体的服务信息
    lease-expiration-duration-in-seconds: 5 # 服务实例的续约的时间间隔  eureka-server是服务端也是客户端

</code></pre></div><p>4.修改启动程序</p> <p>5.Edit Configurations</p> <p>6.进入server管理界面查看</p> <div class="language- extra-class"><pre class="language-text"><code>http://localhost:8761/
http://localhost:8762/
http://localhost:8763/
</code></pre></div><p>7.此时不是集群 没有数据交互</p> <div class="language- extra-class"><pre class="language-text"><code>需要搞三台电脑
修改 ‪C:\Windows\System32\drivers\etc\hosts 文件来欺骗他
添加：
	127.0.0.1 peer1
	127.0.0.1 peer2
	127.0.0.1 peer3
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>修改application.yml

a
defaultZone: http://peer2:8762/eureka,http://peer3:8763/eureka
hostname: peer1 # 主机名称或者服务ip
三个都要对应修改
</code></pre></div><p>8.进入server管理界面查看</p> <div class="language- extra-class"><pre class="language-text"><code>http://localhost:8761/
http://localhost:8762/
http://localhost:8763/

DS Replicas 查看
</code></pre></div><p>9.测试</p> <p>让client注册</p> <h3 id="_2-eureka-client"><a href="#_2-eureka-client" class="header-anchor">#</a> 2.eureka-client</h3> <p>3.修改application.yml</p> <div class="language- extra-class"><pre class="language-text"><code>server:
  port: 8080
spring:
  application:
    name: eureka-client-a
eureka:
  client:
    service-url: # ???????
      defaultZone: http://peer1:8761/eureka      ！！！！！！！！！！修改为peer1！！！！！！
    register-with-eureka: true # false????eureka-server??
    fetch-registry: true # ???????? ???false?????????????
    registry-fetch-interval-seconds: 10  # ??????????? ????????????? ????-&gt;????-&gt;??????
  instance: # ????
    instance-id: ${eureka.instance.hostname}:${spring.application.name}:${server.port} #?????????????
    hostname: localhost # ??????? ???ip
    prefer-ip-address: true #?ip????????????
    lease-expiration-duration-in-seconds: 10 # ????????????
</code></pre></div><p>6.进入server管理界面查看</p> <div class="language- extra-class"><pre class="language-text"><code>发现配置文件中只注册了peer1，结果是全部都注册了，是server集群的扩散造成的。
</code></pre></div><h3 id="_3-搭建eureka-server集群的终极方案"><a href="#_3-搭建eureka-server集群的终极方案" class="header-anchor">#</a> 3.搭建eureka-server集群的终极方案</h3> <p>发现只有hostname、端口和defaultZone不一样</p> <p>使用配置文件来搭建</p> <div class="language- extra-class"><pre class="language-text"><code>先创建第一台

其中配置文件为：
# 集群的终极方案
server:
  port: 8761 #eureka默认端口
spring:
  application:
    name: eureka-server #应用名称
eureka:
  client:
    service-url: #向其他机器注册 默认向8761注册
      defaultZone: http://peer1:8761/eureka,http://peer2:8762/eureka,http://peer3:8763/eureka
  instance: # 实例的配置
    instance-id: ${spring.application.name}:${server.port} #主机名称：应用名称：端口号
#    hostname: peer1 # 主机名称或者服务ip
    prefer-ip-address: true #以ip的形式显示具体的服务信息
    lease-expiration-duration-in-seconds: 5 # 服务实例的续约的时间间隔  eureka-server是服务端也是客户端
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>建立好第一台后
我们只需要修改配置文件的端口，启动3台即可.
</code></pre></div><h3 id="_4-搭建eureka-client集群的终极方案"><a href="#_4-搭建eureka-client集群的终极方案" class="header-anchor">#</a> 4.搭建eureka-client集群的终极方案</h3> <p>使用配置文件来搭建</p> <div class="language- extra-class"><pre class="language-text"><code>先创建第一台

其中配置文件为：       !!!!向所有的都注册!!!!!!!!!!向所有的都注册!!!!!!!!!!向所有的都注册!!!!!!
# client终极方案
server:
  port: 8080
spring:
  application:
    name: eureka-client-a
eureka:
  client:
    service-url: # ???????
      defaultZone: http://peer1:8761/eureka,http://peer2:8762/eureka,http://peer3:8763/eureka !!!!向所有的都注册!!!!!!
    register-with-eureka: true # false????eureka-server??
    fetch-registry: true # ???????? ???false?????????????
    registry-fetch-interval-seconds: 10  # ??????????? ????????????? ????-&gt;????-&gt;??????
  instance: # ????
    instance-id: ${eureka.instance.hostname}:${spring.application.name}:${server.port} #?????????????
    hostname: localhost # ??????? ???ip
    prefer-ip-address: true #?ip????????????
    lease-expiration-duration-in-seconds: 10 # ????????????
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>建立好第一台后
我们只需要修改配置文件的端口，启动3台即可.
</code></pre></div><h2 id="集群的深入理解"><a href="#集群的深入理解" class="header-anchor">#</a> 集群的深入理解</h2> <p>如果是主从模式，主机改怎么选择，怎么保证数据的一致性?</p> <p><a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener noreferrer">筏 (thesecretlivesofdata.com)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>哨兵模式：如果主机挂了，选择一个从计当主机。选哪台？投票!怎么投票？根据分布式数据一致性协议来投票!分布式数据一致性协议包括1.选主机2.保持数据一致性!</p> <h2 id="eureka概念理解"><a href="#eureka概念理解" class="header-anchor">#</a> Eureka概念理解</h2> <h3 id="_1-服务的注册"><a href="#_1-服务的注册" class="header-anchor">#</a> 1.服务的注册</h3> <p>当服务(客户端)启动时，会向eureka-server发送自己的原始数据，eureka-server会在自己内存中保存这些数据(服务列表)。</p> <h3 id="_2-服务的续约"><a href="#_2-服务的续约" class="header-anchor">#</a> 2.服务的续约</h3> <p>服务启动了，除了注册外，还会定时向eureka-server汇报自己，表示自己还活着。(心跳机制)</p> <h3 id="_3-服务的下线"><a href="#_3-服务的下线" class="header-anchor">#</a> 3.服务的下线</h3> <p>服务关闭了，会给eureka-server报告。eureka-server会告诉其他服务，这个服务下线了。</p> <h3 id="_4-服务的剔除"><a href="#_4-服务的剔除" class="header-anchor">#</a> 4.服务的剔除</h3> <p>如果服务超过了eureka-server的指定时间汇报自己，eureka-server认为改服务挂掉了。</p> <h3 id="_5-eureka-server端的功能"><a href="#_5-eureka-server端的功能" class="header-anchor">#</a> 5.eureka-server端的功能</h3> <p>1.通讯录功能：有一份服务列表记录各个服务信息。服务拿到这个服务列表就可以调用其他服务。</p> <p>2.服务订阅功能：当新的服务上线了或者下线了，会告诉各个服务，更新服务列表。</p> <p>3.服务健康监测功能</p> <h2 id="eureka源码理解"><a href="#eureka源码理解" class="header-anchor">#</a> Eureka源码理解</h2> <h3 id="_1-学习源码可以排查bug和优化代码。"><a href="#_1-学习源码可以排查bug和优化代码。" class="header-anchor">#</a> 1.学习源码可以排查bug和优化代码。</h3> <h3 id="_2-eureka运作原理"><a href="#_2-eureka运作原理" class="header-anchor">#</a> 2.eureka运作原理</h3> <p>eureka-server对外提供的是restful风格的服务。get、post、put、delete发请求。</p> <p>eureka利用restful风格的接口来实现注册和发现。</p> <h3 id="_3-服务注册的源码分析〖重点〗"><a href="#_3-服务注册的源码分析〖重点〗" class="header-anchor">#</a> 3.服务注册的源码分析〖重点〗</h3> <p>客户端怎么发-----server端怎么接收怎么保存</p> <p>客户端怎么发：</p> <p>客户端发送一个请求把自己的信息给服务端。</p> <p>server接收到请求后，把信息存到</p> <h3 id="_4-服务续约"><a href="#_4-服务续约" class="header-anchor">#</a> 4.服务续约</h3> <p>本质就是发一个更新请求(put)。</p> <h3 id="_5-服务发现"><a href="#_5-服务发现" class="header-anchor">#</a> 5.服务发现</h3> <p>服务a要调用服务b</p> <p>服务a根据服务的应用名称找到服务的ip和端口。</p> <p>在java代码中发起http请求，拿到数据。</p> <div class="language- extra-class"><pre class="language-text"><code>@RestController
@RequestMapping(&quot;/order&quot;)
public class OrderController {
    @Autowired
    RestTemplate restTemplate;

    @Autowired
    private DiscoveryClient discoveryClient;

    @GetMapping(&quot;/add/{id}&quot;)
    public Goods add(@PathVariable(&quot;id&quot;) Integer id){
        //业务逻辑
        //1查询商品
        //2减库存
        //3支付
        //4物流
        //直接调用
        //String url=&quot;http://localhost:8000/goods/findById/&quot;+id;
        //Goods goods = restTemplate.getForObject(url, Goods.class);

        //服务发现
        List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(&quot;EUREKA-PROVIDER&quot;);
        if(instances==null||instances.size()&lt;=0){
            return null;
        }
        //通过某个策略拿到一个实例
        ServiceInstance serviceInstance = instances.get(0);
        String host = serviceInstance.getHost();
        int port = serviceInstance.getPort();
        System.out.println(host);
        System.out.println(port);

        String url=&quot;http://&quot;+host+&quot;:&quot;+port+&quot;/goods/findById/&quot;+id;
        Goods goods = restTemplate.getForObject(url, Goods.class);

        return goods;
    }
}
</code></pre></div><h2 id="eureka服务发现和调用服务"><a href="#eureka服务发现和调用服务" class="header-anchor">#</a> Eureka服务发现和调用服务</h2> <h3 id="环境"><a href="#环境" class="header-anchor">#</a> 环境</h3> <p>一个注册中心eureka-server；俩个客户端client-a和client-b都已经注册；</p> <h3 id="目标"><a href="#目标" class="header-anchor">#</a> 目标</h3> <p>一个用户访问client-a，client-a需要调用client-b的服务；</p> <h3 id="必备知识"><a href="#必备知识" class="header-anchor">#</a> 必备知识</h3> <p>eureka的服务发现和java发请求</p> <h3 id="实现"><a href="#实现" class="header-anchor">#</a> 实现</h3> <p>eureka-a的接口</p> <div class="language- extra-class"><pre class="language-text"><code>@RestController
public class TestController {
    @Autowired
    private DiscoveryClient discoveryClient;
    @GetMapping(&quot;/test&quot;)
    public String test() {
        // 知识点 服务发现
        // 根据应用名称获取服务的ip和端口
        List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(&quot;EUREKA-CLIENT-B&quot;);
        ServiceInstance b = instances.get(0);
        String host = b.getHost();
        int port = b.getPort();
        // 拼接url
        String url = &quot;http://&quot; + host + &quot;:&quot; +port + &quot;/getUserInfo&quot;;
        System.out.println(url);
        // 使用restTemplate发送请求
        RestTemplate restTemplate = new RestTemplate();
        String result = restTemplate.getForObject(url, String.class);
        System.out.println(result);
        return &quot;ok&quot;;
    }
}
</code></pre></div><p>eureka-a的接口</p> <div class="language- extra-class"><pre class="language-text"><code>@RestController
public class TestController {
    @GetMapping(&quot;/getUserInfo&quot;)
    public String test(){
        return &quot;这是服务b提供的服务&quot;;
    }
}
</code></pre></div><h3 id="结果"><a href="#结果" class="header-anchor">#</a> 结果</h3> <div class="language- extra-class"><pre class="language-text"><code>向a发送get请求：http://localhost:8080/test

结果：
http://169.254.141.199:8081/getUserInfo
这是服务b提供的服务
</code></pre></div><h1 id="_2-ribbon"><a href="#_2-ribbon" class="header-anchor">#</a> 2.Ribbon</h1> <h2 id="ibbon初理解"><a href="#ibbon初理解" class="header-anchor">#</a> ibbon初理解</h2> <p>ribbon是一个工具，用来给<strong>客户端</strong>提供负载均衡服务的，主要提供负载均衡算法和服务调用。简单来说：ribbon帮我们发起一个远程调用并提供负载均衡服务。</p> <h2 id="ribbon快速入门"><a href="#ribbon快速入门" class="header-anchor">#</a> ribbon快速入门</h2> <h3 id="环境-2"><a href="#环境-2" class="header-anchor">#</a> 环境</h3> <p>一个注册中心，一个provider集群，一个consumer</p> <h3 id="前置知识-2"><a href="#前置知识-2" class="header-anchor">#</a> 前置知识</h3> <p>提供者和消费者都是client，消费者是在浏览器上调用而已，提供者往往提供远程调用服务</p> <h3 id="搭建consumer"><a href="#搭建consumer" class="header-anchor">#</a> 搭建consumer</h3> <p>流程和eureka-client一致</p> <h3 id="不同点"><a href="#不同点" class="header-anchor">#</a> 不同点</h3> <div class="language- extra-class"><pre class="language-text"><code>        ribbon依赖
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;
            &lt;version&gt;2.2.9.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>@SpringBootApplication
@EnableEurekaClient
public class ConsumerApplication {

    public static void main(String[] args) {
        SpringApplication.run(ConsumerApplication.class, args);
    }


    @Bean // 注入RestTemplate对象到容器
    @LoadBalanced // 使用ribbon优化RestTemplate对象
    public RestTemplate restTemplate(){
        return new RestTemplate();
    }
}
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>@RestController
public class ConsumerController {

    @Autowired
    private RestTemplate restTemplate;

    @GetMapping(&quot;/testRibbon&quot;)
    public String testRibbon(String serviceName) {
        // 这里没有提供端口 让ribbon来选择
        String result = restTemplate.getForObject(&quot;http://&quot; + serviceName + &quot;/hello&quot;, String.class);
        return result;
    }
}
</code></pre></div><h2 id="ribbon负载均衡理解"><a href="#ribbon负载均衡理解" class="header-anchor">#</a> ribbon负载均衡理解</h2> <h3 id="注意点1"><a href="#注意点1" class="header-anchor">#</a> 注意点1</h3> <p>你需要知道@LoadBalanced优化了RestTemplate对象后，如果你想使用原生的RestTemplate对象，你需要重新创建一个对象。</p> <h3 id="轮训算法的代码实现"><a href="#轮训算法的代码实现" class="header-anchor">#</a> 轮训算法的代码实现</h3> <p>List&lt;机器&gt;     取模运算 size集群的台数</p> <p>全局变量 i = 0</p> <p>每访问一次 i++</p> <p>i%size</p> <p>为了线程安全 加CAS自选锁</p> <h2 id="ribbon源码理解"><a href="#ribbon源码理解" class="header-anchor">#</a> ribbon源码理解</h2> <p>没有过于深的理解</p> <h2 id="修改负载均衡算法"><a href="#修改负载均衡算法" class="header-anchor">#</a> 修改负载均衡算法</h2> <p>访问不同的服务可以选择不同的负载均衡算法</p> <p>1.修改yml文件</p> <div class="language- extra-class"><pre class="language-text"><code>provider: #先写服务者的应用名称
  ribbon:
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule #算法的全限定类名 Rule  com.netflix.loadbalancer.RandomRule
</code></pre></div><p>2.全局配置</p> <div class="language- extra-class"><pre class="language-text"><code>    /**
     * 往容器放一个rule对象
     * 访问任何一个提供者都使用这个算法
     * @return
     */
    @Bean
    public IRule myRule(){
        return new RandomRule();
    }
</code></pre></div><h2 id="ribbon总结"><a href="#ribbon总结" class="header-anchor">#</a> Ribbon总结</h2> <div class="language- extra-class"><pre class="language-text"><code>Ribbon 是 客户端实现负载均衡的远程调用组件 ，用法简单
Ribbon 源码核心：
ILoadBalancer 接口：起到承上启下的作用
1. 承上：从 eureka 拉取服务列表
2. 启下：使用 IRule 算法实现客户端调用的负载均衡

   设计思想：每一个服务提供者都有自己的 ILoadBalancer
   userService--- 》客户端有自己的 ILoadBalancer
   TeacherService--- 》客户端有自己的 ILoadBalancer
   在客户端里面就是 Map&lt;String,ILoadBalancer&gt; iLoadBalancers
   Map&lt;String,ILoadBalancer&gt; iLoadBalancers 消费者端
   服务提供者的名称 value （服务列表 算法规则 ）
   如何实现负载均衡的呢？
   iloadBalancer loadbalance = iloadBalancers.get(“user-service”)
   List&lt;Server&gt; servers = Loadbalance.getReachableServers();// 缓存起来
   Server server = loadbalance .chooseServer(key) //key 是区 id ， -- 》 IRule 算法
   chooseServer 下面有一个 IRule 算法
   IRule 下面有很多实现的负载均衡算法
   你就可以使用 eureka+ribbon 做分布式项目
</code></pre></div><h1 id="_3-openfeign"><a href="#_3-openfeign" class="header-anchor">#</a> 3.OpenFeign</h1> <h2 id="openfeign是什么"><a href="#openfeign是什么" class="header-anchor">#</a> OpenFeign是什么？</h2> <p>OpenFeign是一个声明式的web service client，帮我们实现远程服务调用的。ribbon来解决负载均衡，OpenFeign进一步优化远程服务调用。注意：feign只是封装了ribbon，底层是ribbon。</p> <h2 id="openfeign快速入门"><a href="#openfeign快速入门" class="header-anchor">#</a> OpenFeign快速入门</h2> <h3 id="环境-3"><a href="#环境-3" class="header-anchor">#</a> 环境</h3> <p>一个注册中心，两个服务user-service和orderservice</p> <h3 id="结构"><a href="#结构" class="header-anchor">#</a> 结构</h3> <div class="language-mermaid extra-class"><pre class="language-mermaid"><code><span class="token keyword">graph</span> TB
  注册中心<span class="token text string">(注册中心)</span>
  user-service<span class="token arrow operator">--&gt;</span>注册中心<span class="token text string">(注册中心)</span>
  order-service<span class="token arrow operator">--&gt;</span>注册中心<span class="token text string">(注册中心)</span>

</code></pre></div><h3 id="业务"><a href="#业务" class="header-anchor">#</a> 业务</h3> <p>浏览器访问user-service提供的服务，user-service调用order-service的服务</p> <h3 id="实现-2"><a href="#实现-2" class="header-anchor">#</a> 实现</h3> <p>1.order-service的服务</p> <div class="language- extra-class"><pre class="language-text"><code>@RestController
public class OrderController {
    @GetMapping(&quot;/doOrder&quot;)
    public String doOrder() {
        return &quot;油条&quot;;
    }
}
</code></pre></div><p>2.user-service添加pom依赖</p> <div class="language- extra-class"><pre class="language-text"><code>        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre></div><p>3.user-service启动类添加@EnableFeignClients注解</p> <div class="language- extra-class"><pre class="language-text"><code>@SpringBootApplication
@EnableEurekaClient
@EnableFeignClients // 开启openfeign
public class UserServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(UserServiceApplication.class, args);
    }

}
</code></pre></div><p>4.在xyz.zch1337.feign包中新建UserOrderFeign接口</p> <div class="language- extra-class"><pre class="language-text"><code>package xyz.zch1337.feign;

import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;

@FeignClient(value = &quot;order-service&quot;)
public interface UserOrderFeign { //接口名 要见知意
	// 写需要的服务方法签名
    @GetMapping(&quot;/doOrder&quot;)
    public String doOrder();
}
</code></pre></div><p>5.user-service注入并调用</p> <div class="language- extra-class"><pre class="language-text"><code>@RestController
public class UserController {

    @Autowired // 注入
    private UserOrderFeign userOrderFeign;

    @GetMapping(&quot;/userDoOrder&quot;)
    public String userDoOrder() {
        System.out.println(&quot;用户来了&quot;);
        // 调用
        String s = userOrderFeign.doOrder();
        return s;
    }
}
</code></pre></div><h2 id="openfeign超时调用"><a href="#openfeign超时调用" class="header-anchor">#</a> OpenFeign超时调用</h2> <p>feign默认等待时间是1s，超过就报错</p> <p>user-service可以配置等待时间</p> <p>注意：feign只是封装了ribbon，底层是ribbon</p> <p>user-service   yml</p> <div class="language- extra-class"><pre class="language-text"><code>ribbon:
  ReadTimeout: 3000 #超时等待时间为3s 默认1s
  ConnectTimeout: 3000 #修改连接时长为3s 默认1s
</code></pre></div><h2 id="openfeign日志"><a href="#openfeign日志" class="header-anchor">#</a> OpenFeign日志</h2> <p>yml 开启日志打印</p> <div class="language- extra-class"><pre class="language-text"><code>logging:
  level:
      xyz.zch1337.feign.UserOrderFeign: debug  #打印这个接口下的日志
</code></pre></div><p>启动类 注入</p> <div class="language- extra-class"><pre class="language-text"><code>@SpringBootApplication
@EnableEurekaClient
@EnableFeignClients // 开启openfeign
public class UserServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(UserServiceApplication.class, args);
    }


    /***
     * 打印日志信息
     * @return
     */
    @Bean
    public Logger.Level level() {
        return Logger.Level.FULL;
    }

}
</code></pre></div><h1 id="_4-hystrix"><a href="#_4-hystrix" class="header-anchor">#</a> 4.Hystrix</h1> <p>熔断器，也可以叫断路器。用来保护微服务不雪崩。正常情况下，断路器是关闭状态，当出问题了，才会打开。</p> <h2 id="服务雪崩概念"><a href="#服务雪崩概念" class="header-anchor">#</a> 服务雪崩概念</h2> <p>在微服务中，会存在大量的链式调用，a调b，b调c，如果c宕机了，会导致a和b线程没法及时回收，在高并发的压力下，容易引起服务器宕机。</p> <p>服务雪崩的本质：没有及时回收线程。</p> <p>解决方法：</p> <ol><li>b调c时，减小超时等待时间。效果：可以轻微但不灵活。</li> <li>b调c前，先判断下一层服务的状态，如果c宕机了，直接return。</li></ol> <h2 id="hystrix快速入门"><a href="#hystrix快速入门" class="header-anchor">#</a> Hystrix快速入门</h2> <ol><li><p>依赖</p> <div class="language- extra-class"><pre class="language-text"><code>        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre></div></li> <li><p>写CustomerRentFeignHystrix实现接口，注意规范</p> <p><img src="https://raw.githubusercontent.com/zhuchenghao1337/github-images/main/2022/20221230141204.png" alt=""></p> <div class="language- extra-class"><pre class="language-text"><code>CustomerRentFeignHystrix

@Component // 要注入容器
public class CustomerRentFeignHystrix implements CustomerRentFeign {
    // 这个方法就是备选方案
    @Override
    public String rent() {
        return &quot;我被hystrix处理了&quot;;
    }
}
</code></pre></div></li> <li><p>CustomerRentFeign接口添加注解</p> <div class="language- extra-class"><pre class="language-text"><code>@FeignClient(value = &quot;rent-car-service&quot;,fallback = CustomerRentFeignHystrix.class) // 指定让那个类来处理失败
public interface CustomerRentFeign {
    @GetMapping(&quot;/rent&quot;)
    public String rent();
}
</code></pre></div></li> <li><p>开启hystrix熔断器</p> <div class="language- extra-class"><pre class="language-text"><code>server:
  port: 8081
spring:
  application:
    name: customer-service
eureka:
  client:
    service-url: # ???????
      defaultZone: http://120.46.166.176:8761/eureka
  instance: # ????
    instance-id: ${eureka.instance.hostname}:${spring.application.name}:${server.port} #?????????????
    hostname: localhost # ??????? ???ip
    prefer-ip-address: true #?ip????????????
feign:
  hystrix:
    enabled: true #默认是关闭的 需要手动打开
</code></pre></div></li> <li><p>结果</p> <p><img src="https://raw.githubusercontent.com/zhuchenghao1337/github-images/main/2022/20221230141831.png" alt=""></p></li></ol> <h2 id="熔断器理解"><a href="#熔断器理解" class="header-anchor">#</a> 熔断器理解</h2> <p>本质就是一个拦截器，远程调用前先判断下层服务的状态。</p> <p>注意：hystrix的本质是代理feign的请求来完成熔断的效果。</p> <p>原理：</p> <p><img src="https://raw.githubusercontent.com/zhuchenghao1337/github-images/main/2022/20221230143531.png" alt=""></p> <h2 id="hystrix配置"><a href="#hystrix配置" class="header-anchor">#</a> Hystrix配置</h2> <div class="language- extra-class"><pre class="language-text"><code>server:
  port: 8081
spring:
  application:
    name: customer-service
eureka:
  client:
    service-url: # ???????
      defaultZone: http://120.46.166.176:8761/eureka
  instance: # ????
    instance-id: ${eureka.instance.hostname}:${spring.application.name}:${server.port} #?????????????
    hostname: localhost # ??????? ???ip
    prefer-ip-address: true #?ip????????????
feign:  #开启feign的hystrix
  hystrix:
    enabled: true
hystrix: #hystrix 的全局控制
  command:
    default: #default 是全局控制，也可以换成单个方法控制，把 default 换成方法名即可
      fallback:
        isolation:
          semaphore:
            maxConcurrentRequests: 1000 #信号量隔离级别最大并发数
      circuitBreaker:
        enabled: true #开启断路器
        requestVolumeThreshold: 3 #失败次数（阀值）
        sleepWindowInMilliseconds: 20000 #窗口时间
        errorThresholdPercentage: 60 #失败率
      execution:
        isolation:
          Strategy: thread #隔离方式 thread 线程隔离集合和 SEMAPHORE 信号量隔离级别
          thread:
            timeoutInMilliseconds: 3000 #调用超时时长
ribbon:
  ReadTimeout: 5000 #要结合 feign 的底层 ribbon 调用的时长
  ConnectTimeout: 500
</code></pre></div><h1 id="_5-分布式feign的工程化结构"><a href="#_5-分布式feign的工程化结构" class="header-anchor">#</a> 5.分布式feign的工程化结构</h1> <p><img src="https://raw.githubusercontent.com/zhuchenghao1337/github-images/main/2022/20221230193933.png" alt=""></p> <h1 id="_6-sleuth"><a href="#_6-sleuth" class="header-anchor">#</a> 6.Sleuth</h1> <h2 id="zipkin可视化的监控控制台"><a href="#zipkin可视化的监控控制台" class="header-anchor">#</a> zipkin可视化的监控控制台</h2> <p>运行 zipkin</p> <p>java -jar zipkin-server-2.12.9-exec.jar</p> <p>http://localhost:9411/  查看</p> <h2 id="sleuth快速入门"><a href="#sleuth快速入门" class="header-anchor">#</a> Sleuth快速入门</h2> <p>1.依赖</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;dependency&gt;
&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
&lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;
&lt;/dependency
</code></pre></div><p>2.yml配置文件</p> <p>需要被监控的服务 都要配置</p> <div class="language- extra-class"><pre class="language-text"><code>server:
  port: 8080
spring:
  application:
    name: order-service
  zipkin:
    base-url: http://localhost:9411
  sleuth:
    sampler:
      probability: 1 #配置采样率 默认的采样比例为: 0.1，即 10%，所设置的值介于 0 到 1 之间，1 则表示全部采集
      rate: 10 #为了使用速率限制采样器,选择每秒间隔接受的 trace 量
eureka:
  client:
    service-url: # ???????
      defaultZone: http://120.46.166.176:8761/eureka
  instance: # ????
    instance-id: ${eureka.instance.hostname}:${spring.application.name}:${server.port} #?????????????
    hostname: localhost # ??????? ???ip
    prefer-ip-address: true #?ip????????????
</code></pre></div><h1 id="_7-监控中心"><a href="#_7-监控中心" class="header-anchor">#</a> 7.监控中心</h1> <p>1.依赖</p> <div class="language- extra-class"><pre class="language-text"><code>           &lt;spring-boot-admin.version&gt;2.3.0&lt;/spring-boot-admin.version&gt;
           
		&lt;dependency&gt;
            &lt;groupId&gt;de.codecentric&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-admin-starter-server&lt;/artifactId&gt;
        &lt;/dependency&gt;           
           
           &lt;dependency&gt;
                &lt;groupId&gt;de.codecentric&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-admin-dependencies&lt;/artifactId&gt;
                &lt;version&gt;${spring-boot-admin.version}&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;
</code></pre></div><p>2.yml</p> <div class="language- extra-class"><pre class="language-text"><code>server:
  port: 10086
spring:
  application:
    name: admih-server
eureka:
  client:
    service-url: # ???????
      defaultZone: http://120.46.166.176:8761/eureka
  instance: # ????
    instance-id: ${eureka.instance.hostname}:${spring.application.name}:${server.port} #?????????????
    hostname: localhost # ??????? ???ip
    prefer-ip-address: true #?ip????????????
management:
  endpoints:
    web:
      exposure:
        include: '*' # 暴露所有的监控端点

</code></pre></div><p>3.启动类</p> <div class="language- extra-class"><pre class="language-text"><code>@SpringBootApplication
@EnableEurekaClient
@EnableAdminServer // 开启服务监控
public class AdminServerApplication {

    public static void main(String[] args) {
        SpringApplication.run(AdminServerApplication.class, args);
    }

}
</code></pre></div><p>4.结果</p> <p>可以在控制台看到所有的接口 这里没有启动</p> <p><img src="https://raw.githubusercontent.com/zhuchenghao1337/github-images/main/2022/20221231222916.png" alt=""></p> <p>也可以在zipkin看到</p> <h1 id="_8-gateway"><a href="#_8-gateway" class="header-anchor">#</a> 8.Gateway</h1> <h2 id="网关的理解"><a href="#网关的理解" class="header-anchor">#</a> 网关的理解</h2> <p><img src="https://raw.githubusercontent.com/zhuchenghao1337/github-images/main/2022/20221230213703.png" alt=""></p> <h2 id="网关的作用"><a href="#网关的作用" class="header-anchor">#</a> 网关的作用</h2> <ol><li>路由转发</li> <li>安全控制</li> <li>负载均衡等</li></ol> <h2 id="gateway流程"><a href="#gateway流程" class="header-anchor">#</a> Gateway流程</h2> <p><img src="https://raw.githubusercontent.com/zhuchenghao1337/github-images/main/2022/20200728132755585.jpg" alt=""></p> <p>核心是：路由转发+过滤器链</p> <h2 id="gateway和nginx的区别"><a href="#gateway和nginx的区别" class="header-anchor">#</a> Gateway和nginx的区别</h2> <p>gateway是项目级别的，nginx是服务器级别的。</p> <p><img src="https://raw.githubusercontent.com/zhuchenghao1337/github-images/main/2022/20221230215524.png" alt=""></p> <h2 id="gateway快速入门"><a href="#gateway快速入门" class="header-anchor">#</a> Gateway快速入门</h2> <h2 id="网关集群"><a href="#网关集群" class="header-anchor">#</a> 网关集群</h2> <p>起多台网关 在nginx里面配置</p> <h2 id="代码方式路由和断言工厂"><a href="#代码方式路由和断言工厂" class="header-anchor">#</a> 代码方式路由和断言工厂</h2> <p>配置文件路由</p> <div class="language- extra-class"><pre class="language-text"><code>@Configuration
public class RouteConfig {
    @Bean
    public RouteLocator customRouteLocator(RouteLocatorBuilder builder) {
        return builder.routes()
                // id要唯一  /guochuang 匹配条件  如果匹配成功 去https://www.bilibili.com/guochuang  会拼接在后面
                .route(&quot;test-id1&quot;, r -&gt; r.path(&quot;/guochuang&quot;)
                        .uri(&quot;https://www.bilibili.com/&quot;))
                .route(&quot;test-id2&quot;, r -&gt; r.path(&quot;/variety&quot;)
                        .uri(&quot;https://www.bilibili.com/&quot;))
                .build();
    }
}
</code></pre></div><p>yml路由</p> <div class="language- extra-class"><pre class="language-text"><code>spring:
  application:
    name: gateway-server
  redis:
    host: 124.222.237.176
    port: 6379
  cloud:
    gateway:
      enabled: true
      discovery:
        locator:
          enabled: true # ??????
          lower-case-service-id: true # ??
      routes:
        - id: login-service-route
          uri: http://localhost:8081
          predicates: # 断言
            - Path=/doLogin # 条件
</code></pre></div><h2 id="动态路由和断言工厂"><a href="#动态路由和断言工厂" class="header-anchor">#</a> 动态路由和断言工厂</h2> <p>Gateway 会根据注册中心的服务列表，以注册中心上微服务名为路径创建动态路 由进行转发，从而实现动态路由的功能</p> <p>需要在注册中心注册</p> <h3 id="动态路由"><a href="#动态路由" class="header-anchor">#</a> 动态路由</h3> <div class="language- extra-class"><pre class="language-text"><code>server:
  port: 80
spring:
  application:
    name: gateway-server
  redis:
    host: 124.222.237.176
    port: 6379
  cloud:
    gateway:
      enabled: true
      discovery:
        locator:
          enabled: true # 开启动态路由
          lower-case-service-id: true # 允许小写
      routes:
        - id: login-service-route
          uri: http://localhost:8081
          predicates: # 断言
            - Path=/doLogin # 条件
eureka:
  client:
    service-url: # ???????
      defaultZone: http://120.46.166.176:8761/eureka
    registry-fetch-interval-seconds: 3 # ????????????
  instance: # ????
    instance-id: ${eureka.instance.hostname}:${spring.application.name}:${server.port} #?????????????
    hostname: localhost # ??????? ???ip
    prefer-ip-address: true #?ip????????????
</code></pre></div><p>使用：</p> <p><a href="http://localhost/login-service/doLogin" target="_blank" rel="noopener noreferrer">localhost/login-service/doLogin<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>    localhost/服务名/接口  就可以访问</p> <h3 id="断言工厂"><a href="#断言工厂" class="header-anchor">#</a> 断言工厂</h3> <div class="language- extra-class"><pre class="language-text"><code>server:
  port: 80
spring:
  application:
    name: gateway-server
  redis:
    host: 124.222.237.176
    port: 6379
  cloud:
    gateway:
      enabled: true
      discovery:
        locator:
          enabled: true # 开启动态路由
          lower-case-service-id: true # 允许小写
      routes:
        - id: login-service-route
#          uri: http://localhost:8081
          uri: lb://login-service #使用lb协议 微服务名称做负均衡
          predicates: # 断言匹配
            - Path=/doLogin # 条件 可以使用正则
            - After=2020-01-20T17:42:47.789-07:00[Asia/Shanghai] #此断言匹配发生在指定日期时间之后的请求，ZonedDateTime dateTime=ZonedDateTime.now()获得
            - Method=GET,POST
            - Query=username,cxs #查询路由断言工厂接受两个参数
eureka:
  client:
    service-url: # ???????
      defaultZone: http://120.46.166.176:8761/eureka
    registry-fetch-interval-seconds: 3 # ????????????
  instance: # ????
    instance-id: ${eureka.instance.hostname}:${spring.application.name}:${server.port} #?????????????
    hostname: localhost # ??????? ???ip
    prefer-ip-address: true #?ip????????????
</code></pre></div><h2 id="过滤器"><a href="#过滤器" class="header-anchor">#</a> 过滤器</h2> <p>一般用于修改进入的请求和响应。</p> <p>分类：pre post</p> <p>分类 Gatewayilter GlobalFilter</p> <p>Gatewayilter：针对某一个路由 做过滤    统计请求次数等等</p> <p>GlobalFilter: 统计请求次数 限流 token的校验 ip黑名单 跨域   参数校验</p> <h3 id="自定义过滤器-token校验"><a href="#自定义过滤器-token校验" class="header-anchor">#</a> 自定义过滤器-token校验</h3> <p><img src="https://raw.githubusercontent.com/zhuchenghao1337/github-images/main/2022/20221231151307.png" alt=""></p> <p>为什么用网关来做token校验？</p> <p>很多的服务都需要校验，在网关做token校验就会很好。</p> <div class="language- extra-class"><pre class="language-text"><code>@Configuration
public class TokenCheckFilter implements GlobalFilter, Ordered {
    @Override
    public int getOrder() { // 过滤器顺序
        return 2;
    }
    /**
     * 前后端约定：在请求头上带token 名为：Authorization
     * 1.拿到url
     * 2.判断是否需要token验证 否就直接放行
     * 3.判断是否携带token
     * 4.校验
     * 5.放行/拦截
     * @param exchange
     * @param chain
     * @return
     */
    public static final List&lt;String&gt; ALLOW_URL = Arrays.asList(&quot;/login-service/doLogin&quot;, &quot;/doLogin&quot;);

    @Autowired
    private StringRedisTemplate stringRedisTemplate;

    @Override
    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) {

        ServerHttpRequest request = exchange.getRequest();
        String path = request.getURI().getPath();
        if (ALLOW_URL.contains(path)) {
            return chain.filter(exchange);
        }

        List&lt;String&gt; authorization = request.getHeaders().get(&quot;Authorization&quot;);
        if (!CollectionUtils.isEmpty(authorization)) {
            String token = authorization.get(0);
            if(StringUtils.hasText(token)) {
                String realToken = token.replaceFirst(&quot;bearer &quot;, &quot;&quot;);
                if(StringUtils.hasText(realToken) &amp;&amp; stringRedisTemplate.hasKey(realToken)) {
                    // 放行
                    return chain.filter(exchange);
                }
            }
        }
        // 拦截
        ServerHttpResponse response = exchange.getResponse();
        response.getHeaders().set(&quot;content-type&quot;, &quot;application/json;charset=utf-8&quot;);
        HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;code&quot;, 401);
        map.put(&quot;msg&quot;, &quot;未授权&quot;);
        ObjectMapper objectMapper = new ObjectMapper();
        // 把map转化为字节
        byte[] bytes = new byte[0];
        try {
            bytes = objectMapper.writeValueAsBytes(map);
        } catch (JsonProcessingException e) {
            e.printStackTrace();
        }
        DataBuffer wrap = response.bufferFactory().wrap(bytes);
        return response.writeWith(Mono.just(wrap));
    }
}
</code></pre></div><h2 id="跨域配置"><a href="#跨域配置" class="header-anchor">#</a> 跨域配置</h2> <p>网关是微服务的边缘，所有请求都要走网关，跨域的配置写在网关就很方便。</p> <p>配置文件配置</p> <div class="language- extra-class"><pre class="language-text"><code>import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.reactive.CorsWebFilter;
import org.springframework.web.cors.reactive.UrlBasedCorsConfigurationSource;
import org.springframework.web.util.pattern.PathPatternParser;

@Configuration
public class CorsConfig {

    @Bean
    public CorsWebFilter corsFilter() {
        CorsConfiguration config = new CorsConfiguration();
        config.addAllowedMethod(&quot;*&quot;);
        config.addAllowedOrigin(&quot;*&quot;);
        config.addAllowedHeader(&quot;*&quot;);
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(new PathPatternParser());
        source.registerCorsConfiguration(&quot;/**&quot;, config);
        return new CorsWebFilter(source);
    }
}
</code></pre></div><p>yml配置跨域</p> <div class="language- extra-class"><pre class="language-text"><code>spring:
	cloud:
		gateway:
			globalcors:
				corsConfigurations:
					'[/**]': // 针对哪些路径
						allowCredentials: true // 这个是可以携带 cookie
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.dd397728.js" defer></script><script src="/assets/js/2.6430ac10.js" defer></script><script src="/assets/js/22.d6b62e7e.js" defer></script>
  </body>
</html>
